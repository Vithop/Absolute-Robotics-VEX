#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightencoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftencoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           Arm1,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FrontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           MiddleRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RearRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Arm2,          tmotorNone, openLoop)
#pragma config(Motor,  port6,           Arm3,          tmotorNone, openLoop)
#pragma config(Motor,  port7,           FrontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           MiddleLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RearLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          Arm4,          tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int requestedLeftSpeed 	= 0;
int requestedRightSpeed = 0;
short speedIncrement 		= 1;
short stallSpeed 				= 20;
int maxSpeed 						= 30;
//////////////////////////////////////
int leften 		= -1 * SensorValue[leftencoder];
int righten 	= SensorValue[rightencoder];
//int turn,direction	= 0;
//int difference			= 0;
/////////////////////////////////////////////////////////////////////////////////////////
float rotation = 900;
int heading = 0;
int w = 90;
float deltaheading = 0;
/////////////////////////////////////////////////////////////////////////////////////////
/*task rotate()
{
	while(true){
		if(vexRT[Btn8D] == true){
			//Completely clear out any previous sensor readings by setting the port to "sensorNone"
			SensorType[gyro] = sensorNone;
			wait1Msec(1000);
			//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
			SensorType[gyro] = sensorGyro;
			wait1Msec(2000);

			//Adjust SensorScale to correct the scaling for your gyro
			//SensorScale[in8] = 260;
			//Adjust SensorFullCount to set the "rollover" point. 3600 sets the rollover point to +/-3600
			//SensorFullCount[in8] = 3600;

			//Specify the number of degrees for the robot to turn (1 degree = 10, or 900 = 90 degrees)
			heading = abs(SensorValue[gyro]);
			w = 50;
			deltaheading = 0;
			//While the absolute value of the gyro is less than the desired rotation...
			do
			{
				//...continue turning
				heading = abs(SensorValue[gyro]);
				deltaheading = rotation - heading;
				w = (int)(60*(deltaheading/rotation));
				if (w < stallSpeed && w > 0){
					w = 20;
					}else if (w > (-1*stallSpeed) && w < 0){
					w = -20;
				}
				requestedLeftSpeed = -w;
				requestedRightSpeed = w;
			}while(abs(SensorValue[gyro]) != rotation);

			//Brief brake to stop some drift
			requestedLeftSpeed 		= 0;
			requestedRightSpeed 	= 0;
			wait1Msec(250);
		}
	}
}*/
//////////////////////////////////////////////////////////////////////////////////////////
int isDecelerating (int requested, int current){
	if (abs(requested)< abs(current) && (requested * current) > 0 || (requested * current) < 0)
	{
		return 1;
		}else{
		return 0;
	}
}
//////////////////////////////////////////////////////////////////////////////////////////
int max (short x , short y )
{
	int vithuran = 0.25;
	return x < y ? y : x;
}
//////////////////////////////////////////////////////////////////////////////////////////
task countticks(){ //360 turn will give 2142 to 2390 averages to 2290 ticks for 360
	while(true){
		SensorValue[leftencoder] = 0;
		SensorValue[rightencoder] = 0;

		while(vexRT[Btn6U] == 1){
			leften = SensorValue[leftencoder];
			righten = SensorValue[rightencoder];
			motor[FrontLeft] 		= 100;
			motor[MiddleLeft] 	= 100;
			motor[RearLeft] 		= 100;
			motor[FrontRight] 	= -100;
			motor[MiddleRight] 	= -100;
			motor[RearRight] 		= -100;
		}
		motor[FrontLeft] 		= 0;
		motor[MiddleLeft] 	= 0;
		motor[RearLeft] 		= 0;
		motor[FrontRight] 	= 0;
		motor[MiddleRight] 	= 0;
		motor[RearRight] 		= 0;
	}
}
//////////////////////////////////////////////////////////////////////////////////////////
// when going foward the left side decrease while the right side increase and bckw is opposite
// turning right both increases and turning left both decrease
/*task navigator(){
	while(true){
		while (vexRT[Btn6U] == 0){
			leften = -1*SensorValue[leftencoder];
			righten = SensorValue[rightencoder];

			if (leften < -2290){
				leften = leften + 2290;
				SensorValue[leftencoder] = leften;
				}else if (leften > 2290){
				leften = leften - 2290;
				SensorValue[leftencoder] = leften;
				}else{
				leften = leften;
			}
			if (righten < -2290){
				righten = righten + 2290;
				SensorValue[rightencoder] = righten;
				}else if (righten > 2290){
				righten = righten - 2290;
				SensorValue[rightencoder] = righten;
				}else{
				righten = righten;
			}
		}
	}
}*/
///////////////////////////////////////////////////////
/*task button6U(){
	while(true){
		while(vexRT[Btn6U] == 1){
			SensorValue[leftencoder] = 0;
			SensorValue[rightencoder] = 0;
			leften = leften * -1;
			righten = righten * -1;


			while (leften < SensorValue[leftencoder] * -1 && righten > SensorValue[rightencoder] ){
				motor[FrontLeft] 		= 100;
				motor[MiddleLeft] 	= 100;
				motor[RearLeft] 		= 100;
				motor[FrontRight] 	= -100;
				motor[MiddleRight] 	= -100;
				motor[RearRight] 		= -100;
			}

			while (leften > SensorValue[leftencoder] * -1 && righten < SensorValue[rightencoder]){
				motor[FrontLeft] 		= -100;
				motor[MiddleLeft] 	= -100;
				motor[RearLeft] 		= -100;
				motor[FrontRight] 	= 100;
				motor[MiddleRight] 	= 100;
				motor[RearRight] 		= 100
				;
			}
			motor[FrontLeft] 		= 0;
			motor[MiddleLeft] 	= 0;
			motor[RearLeft] 		= 0;
			motor[FrontRight] 	= 0;
			motor[MiddleRight] 	= 0;
			motor[RearRight] 		= 0;
			SensorValue[leftencoder] = 0;
			SensorValue[rightencoder] = 0;
			leften = 0;
			righten = 0;
		}
	}
}*/
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
task accelerator()
{
	int currentRightSpeed 	= 0;
	int currentLeftSpeed 	= 0;
	while(true){
		while (vexRT[Btn6U] == 0)
		{

			if (requestedLeftSpeed != currentLeftSpeed)
			{


				short Increment = speedIncrement;

				if (isDecelerating (requestedLeftSpeed, currentLeftSpeed) == 1){
					Increment = 20;
				}


				//Eliminate overshoot
				else if (abs(requestedLeftSpeed - currentLeftSpeed) < Increment){
					Increment = abs(requestedLeftSpeed - currentLeftSpeed);
				}

				if (requestedLeftSpeed > currentLeftSpeed) {
					currentLeftSpeed = currentLeftSpeed + Increment;
					}else {
					currentLeftSpeed = currentLeftSpeed - Increment;
				}
				motor[FrontLeft] = -currentLeftSpeed;
				motor[MiddleLeft]= -currentLeftSpeed;
				motor[RearLeft] = -currentLeftSpeed;

			}
			if (requestedRightSpeed != currentRightSpeed)
			{


				short Increment = speedIncrement;

				if (isDecelerating (requestedRightSpeed, currentRightSpeed) == 1){
					Increment = 15;
				}

				else if (abs(requestedRightSpeed - currentRightSpeed) < Increment) {
					Increment = abs(requestedRightSpeed - currentRightSpeed);
				}

				if (requestedRightSpeed > currentRightSpeed) {
					currentRightSpeed = currentRightSpeed + Increment;
					}else {
					currentRightSpeed = currentRightSpeed - Increment;
				}
				motor[FrontRight] = currentRightSpeed;
				motor[MiddleRight]= currentRightSpeed;
				motor[RearRight] = currentRightSpeed;

			}
			wait1Msec(10);
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////////
task joystickMonitorTank()
{
	while(true)
	{
		if (vexRT[Btn5D] ==1)
		{
			maxSpeed 		= 30;
			speedIncrement	= 1;
		}
		else
		{
			maxSpeed		= 127;
			speedIncrement	 = 5;
		}
		float scale 		= (float)maxSpeed / 127.0;
		requestedLeftSpeed 	= (short)(float)((-1 * vexRT[Ch3]) + vexRT[Ch4])*scale;
		requestedRightSpeed	= (short)(float)((-1 * vexRT[Ch3]) - vexRT[Ch4])*scale;
		short maxLR;
		float f;
		if (abs(requestedLeftSpeed)< stallSpeed *scale)
		{
			requestedLeftSpeed 	= 0;
			speedIncrement		= 20;
		}
		if (abs(requestedRightSpeed)< stallSpeed *scale)
		{
			requestedRightSpeed = 0;
			speedIncrement 		= 20;
		}
		maxLR = max( abs (requestedLeftSpeed), abs (requestedRightSpeed));

		if (maxLR > maxSpeed)
		{
			if(abs(requestedLeftSpeed) > abs (requestedRightSpeed))
				f = abs((float)maxSpeed/requestedLeftSpeed);
			else
				f = abs((float)maxSpeed/requestedRightSpeed);
			requestedLeftSpeed = requestedLeftSpeed * f;
			requestedRightSpeed = requestedRightSpeed * f;
		}
		wait1Msec(10);
	}
}
//////////////////////////////////////////////////////////////////////////////////////////
task joystickMonitorArcade()
{
	while(true)
	{
		if (vexRT[Btn5D] ==1)
		{
			maxSpeed 		= 30;
			speedIncrement	= 1;
		}
		else
		{
			maxSpeed		= 127;
			speedIncrement	 = 5;
		}
		float scale 		= (float)maxSpeed / 127.0;
		requestedLeftSpeed 	= (short)(float)((-1 * vexRT[Ch3]))*scale;
		requestedRightSpeed	= (short)(float)((-1 * vexRT[Ch2]))*scale;
		short maxLR;
		float f;
		if (abs(requestedLeftSpeed)< stallSpeed *scale)
		{
			requestedLeftSpeed 	= 0;
			speedIncrement		= 20;
		}
		if (abs(requestedRightSpeed)< stallSpeed *scale)
		{
			requestedRightSpeed = 0;
			speedIncrement 		= 20;
		}
		maxLR = max( abs (requestedLeftSpeed), abs (requestedRightSpeed));

		if (maxLR > maxSpeed)
		{
			if(abs(requestedLeftSpeed) > abs (requestedRightSpeed))
				f = abs((float)maxSpeed/requestedLeftSpeed);
			else
				f = abs((float)maxSpeed/requestedRightSpeed);
			requestedLeftSpeed = requestedLeftSpeed * f;
			requestedRightSpeed = requestedRightSpeed * f;
		}
		wait1Msec(10);
	}
}
//////////////////////////////////////////////////////////////////////////////////////////
task main(){
	//	startTask(rotate);
	startTask(accelerator);
	startTask (joystickMonitorTank);
	while(true){
		wait1Msec(10);
	}
}
