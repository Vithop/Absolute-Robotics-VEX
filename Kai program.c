#pragma config(Motor,  port2,           FrontRight,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           RearRight,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port8,           FrontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RearLeft,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
//#pragma DebuggerWindows ("joystickSimple")
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "JoystickDriver.c"


int sign (int x)
{
	return x < 0 ? -1 : 1;

}

int isDecelerating (int requested, int current)
{
	if ((abs(requested)< abs(current) && sign (requested) == sign (current)) || sign(requested) != sign (current))
		return 1;
	else
		return 0;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


int requestedLeftSpeed = 0;
int requestedRightSpeed = 0;
int speedIncrement = 1;
int stallSpeed = 20;

task driveControl()
{
	int currentLeftSpeed = 0;
	int currentRightSpeed = 0;

	while (true)
	{

		if (requestedLeftSpeed != currentLeftSpeed)
		{


			short Increment = speedIncrement;

			if (isDecelerating (requestedLeftSpeed, currentLeftSpeed))
				Increment = 15;


			//Eliminate overshoot
			if (abs(requestedLeftSpeed - currentLeftSpeed) < Increment)
				Increment = abs(requestedLeftSpeed - currentLeftSpeed);


			if (requestedLeftSpeed > currentLeftSpeed)
				currentLeftSpeed = currentLeftSpeed + Increment;
			else
				currentLeftSpeed = currentLeftSpeed - Increment;

			motor[FrontLeft] = currentLeftSpeed;
			motor[RearLeft] = currentLeftSpeed;

		}
		if (requestedRightSpeed != currentRightSpeed)
		{


			short Increment = speedIncrement;

			if (isDecelerating (requestedRightSpeed, currentRightSpeed))
				Increment = 15;


			if (abs(requestedRightSpeed - currentRightSpeed) < Increment)
				Increment = abs(requestedRightSpeed - currentRightSpeed);


			if (requestedRightSpeed > currentRightSpeed)
				currentRightSpeed = currentRightSpeed + Increment;
			else
				currentRightSpeed = currentRightSpeed - Increment;

			motor[FrontRight] = -currentRightSpeed;
			motor[RearRight] = -currentRightSpeed;

		}
		wait1Msec(10);
	}
}
task joystickMonitor();

task usercontrol()
{
	// User control code here, inside the loop
	int motorSpeed = 100;

//	startTask(servo1Control);
	startTask(driveControl);
	startTask(joystickMonitor);
//	startTask (Tensioner);
//	startTask(shooterControl);
	while (true)
	{
		// This is the main execution loop for the user control program. Each time through the loop
		// your program should update motor + servo values based on feedback from the joysticks.

		// .....................................................................................
		// Insert user code here. This is where you use the joystick values to update your motors, etc.
		// .....................................................................................

		//servo1Degrees = degrees;
		//degrees = -degrees;

		motorSpeed = -motorSpeed;
		//requestedSpeed = motorSpeed;

		wait1Msec(1000);
	}
}
int max (short x , short y )
{
	return x < y ? y : x;
}

int maxSpeed = 30;

task joystickMonitor()
{
	while(true)
	{
		//getJoystickSettings(joystick);

		//requestedSpeed = joystick.joy1_y1;
		if (vexRT[Btn5D] ==1)
		{
			maxSpeed = 30;
			speedIncrement = 1;
		}
		else
		{
			maxSpeed = 127;
			speedIncrement = 5;
		}





		float scale = (float)maxSpeed / 127.0;
		short left = (short)(float)(vexRT[vexJSLeftV] + vexRT[vexJSLeftH])*scale;
		short right = (short)(float)(vexRT[vexJSLeftV] - vexRT[vexJSLeftH])*scale;
		short maxLR;
		float f;


		if ((abs(left)< stallSpeed *scale) && (abs(right)< stallSpeed *scale))
		{
			if (abs(left)< stallSpeed *scale)
			{
				left = 0;
				speedIncrement = 10;
			}
			if (abs(right)< stallSpeed *scale)
			{
				right = 0;
				speedIncrement = 10;
			}
		}

		maxLR = max( abs (left), abs (right));

		if (maxLR > maxSpeed)
		{
			if(abs(left) > abs (right))
				f = abs((float)maxSpeed/left);
			else
				f = abs((float)maxSpeed/right);
			left = left * f;
			right = right * f ;
		}

		requestedLeftSpeed = left;
		requestedRightSpeed = right;

		wait1Msec(10);

	}
}


